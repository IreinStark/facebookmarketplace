rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for cleaner code
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    // USERS COLLECTION RULES
    match /users/{userId} {
      // Anyone can read any user's basic public profile (e.g., for seller info)
      // Consider limiting which fields are exposed to non-owners
      allow read: if true;
      
      // A user can only create their own user document (when they sign up)
      // The document ID must match their authentication UID
      allow create: if isOwner(userId) &&
        // Prevent users from setting themselves as admin during creation
        (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == false) &&
        // Require basic fields
        request.resource.data.keys().hasAll(['email', 'displayName']) &&
        request.resource.data.email == request.auth.token.email;
      
      // A user can update their own profile, but with restrictions
      allow update: if isOwner(userId) &&
        // Prevent changing critical fields unless admin
        (!('isAdmin' in request.resource.data) || 
         resource.data.isAdmin == request.resource.data.isAdmin ||
         isAdmin()) &&
        // Prevent changing email unless it matches auth
        (!('email' in request.resource.data) || 
         request.resource.data.email == request.auth.token.email);
      
      // Users cannot delete their own profiles directly via client-side rules
      allow delete: if false;
      
      // User subcollections (e.g., favorites, notifications)
      match /favorites/{favoriteId} {
        allow read, write: if isOwner(userId);
      }
      
      match /notifications/{notificationId} {
        allow read, write: if isOwner(userId);
      }
    }
    
    // LISTINGS COLLECTION RULES
    match /listings/{listingId} {
      // Anyone can read any listing, but only active ones for non-owners
      allow read: if true; // You might want: resource.data.status == 'active' || resource.data.sellerId == request.auth.uid
      
      // Only logged-in users can create a new listing
      allow create: if isAuthenticated() && 
        request.resource.data.sellerId == request.auth.uid &&
        // Validate required fields
        request.resource.data.keys().hasAll(['title', 'description', 'price', 'sellerId']) &&
        request.resource.data.price is number &&
        request.resource.data.price > 0 &&
        request.resource.data.title is string &&
        request.resource.data.description is string &&
        // Set creation timestamp
        request.resource.data.createdAt == request.time;
      
      // Only the seller can update their own listing
      allow update: if isAuthenticated() && 
        resource.data.sellerId == request.auth.uid &&
        // Prevent changing sellerId
        request.resource.data.sellerId == resource.data.sellerId &&
        // Prevent changing createdAt
        request.resource.data.createdAt == resource.data.createdAt &&
        // Update timestamp
        request.resource.data.updatedAt == request.time;
      
      // Only the seller can delete their own listing
      allow delete: if isAuthenticated() && resource.data.sellerId == request.auth.uid;
    }
    
    // CHATS COLLECTION (for buyer-seller communication)
    match /chats/{chatId} {
      // Only participants can read the chat
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
      
      // Users can create chats if they're one of the participants
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.participants.size() == 2;
      
      // Participants can update chat metadata (like last message time)
      allow update: if isAuthenticated() && 
        request.auth.uid in resource.data.participants &&
        // Prevent changing participants list
        request.resource.data.participants == resource.data.participants;
      
      // Messages subcollection
      match /messages/{messageId} {
        // Only chat participants can read messages
        allow read: if isAuthenticated() && 
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        
        // Users can create messages if they're a participant and the author
        allow create: if isAuthenticated() && 
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants &&
          request.resource.data.authorId == request.auth.uid &&
          request.resource.data.timestamp == request.time;
        
        // Messages cannot be updated or deleted (immutable)
        allow update, delete: if false;
      }
    }
    
    // TRANSACTIONS COLLECTION (for purchase records)
    match /transactions/{transactionId} {
      // Only buyer and seller can read transaction
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.buyerId || 
         request.auth.uid == resource.data.sellerId);
      
      // Transactions are typically created by server-side functions
      // but if created client-side, ensure proper ownership
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.buyerId &&
        request.resource.data.timestamp == request.time;
      
      // Only allow status updates by participants (e.g., marking as completed)
      allow update: if isAuthenticated() && 
        (request.auth.uid == resource.data.buyerId || 
         request.auth.uid == resource.data.sellerId) &&
        // Only allow changing status field
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']) &&
        request.resource.data.updatedAt == request.time;
      
      allow delete: if false; // Transactions should not be deleted
    }
    
    // REVIEWS COLLECTION
    match /reviews/{reviewId} {
      // Anyone can read reviews
      allow read: if true;
      
      // Only buyers can create reviews for purchases they made
      allow create: if isAuthenticated() && 
        request.resource.data.reviewerId == request.auth.uid &&
        // Verify the reviewer actually bought from this seller
        exists(/databases/$(database)/documents/transactions/$(request.resource.data.transactionId)) &&
        get(/databases/$(database)/documents/transactions/$(request.resource.data.transactionId)).data.buyerId == request.auth.uid &&
        request.resource.data.createdAt == request.time;
      
      // Reviewers can update their own reviews within a time limit
      allow update: if isAuthenticated() && 
        resource.data.reviewerId == request.auth.uid &&
        // Allow updates within 24 hours of creation
        request.time < resource.data.createdAt + duration.value(24, 'h') &&
        request.resource.data.updatedAt == request.time;
      
      // Reviews cannot be deleted (for trust and transparency)
      allow delete: if false;
    }
    
    // ADMIN COLLECTION (for app configuration, reports, etc.)
    match /admin/{document} {
      allow read, write: if isAdmin();
    }
    
    // Deny access to any other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}